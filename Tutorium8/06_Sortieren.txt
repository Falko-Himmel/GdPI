Aufgabenstellung: wir haben eine Liste an Elementen und wollen diese sortieren.
Bsp.: [5, 2, 9, 1, 5, 6] ‚Üí [1, 2, 5, 5, 6, 9]

Hier gibt es wieder unteschiedliche Algorithmen mit unterschiedlichen Laufzeiten.

Beispiel: Selection Sort
Gegeben eine zu sortierende Liste ùêπ und eine zu Beginn leere sortierte Liste ùëÜ.
1. Ist ùêπ leer, gib ùëÜ zur√ºck
2. Entferne das kleinste Elemente ùëí aus ùêπ
3. F√ºge ùëí in ùëÜ ein
4. Beginne wieder mit 1.

Beispiel: ùêπ = (21, 5, 3, 17)
ùëÜ = () ùêπ = (21, 5, 3, 17)
ùëÜ = (3) ùêπ = (21, 5, 17)
ùëÜ = (3, 5) ùêπ = (21, 17)
ùëÜ = (3, 5, 17) ùêπ = (21)
ùëÜ = (3, 5, 17, 21) ùêπ = ()

Altklausurenaufgabe: 2024_2 / Aufgabe 7 (ACHTUNG: absteigende Reihenfolge)
https://moodle.uni-ulm.de/pluginfile.php/1348606/mod_folder/content/0/2024_2_exam.pdf

L√∂sung: 
https://moodle.uni-ulm.de/pluginfile.php/1348606/mod_folder/content/0/2024_2_solution.pdf


Wenn wir uns hierf√ºr die Laufzeit √ºberlegen wollen, dann haben wir in Schritt 2 den Aufwand n (Anzahl der Elemente in F) um das kleinste Element zu finden.
Dieser Schritt wird n mal wiederholt (da wir n Elemente sortieren m√ºssen). (hier wird zwar die Liste immer kleiner, aber f√ºr die asymptotische Laufzeitbetrachtung vernachl√§ssigen wir das)


========================================================

Bubble Sort:
Gegeben eine zu sortierende Liste ùêπ.
1. Laufe die ùêπ von vorne nach hinten ab
2. Vergleiche aktuelles Element ùëí mit Nachfolger ùëì
3. Sind ùëí und ùëì in falscher Reihenfolge, tausche die beiden
4. Betrachte nun n√§chstes Element (entweder ùëí oder ùëì je nachdem ob getauscht
wurde oder nicht)
5. Ist das Ende der zu betrachtenden Folge erreicht pr√ºfe ob im aktuellen
Durchlauf mindestens ein Tausch stattgefunden hat, wenn ja beginne bei 1.,
wenn nein beende den Algorithmus.

Beispiel: ùêπ = (5, 2, 9, 1, 5, 6)
Durchlauf 1: (2, 5, 1, 5, 6, 9)
Durchlauf 2: (2, 1, 5, 5, 6, 9)
Durchlauf 3: (1, 2, 5, 5, 6, 9)     

Die Laufzeit von Bubble Sort im schlechtesten Fall ist O(n^2), da in jedem der n Durchl√§ufe bis zu n-1 Vergleiche und m√∂gliche Vertauschungen durchgef√ºhrt werden m√ºssen.




========================================================


Insertion Sort
Gegeben eine zu sortierende Liste ùêπ und eine zu Beginn leere sortierte Folge ùëÜ.
1. Ist ùêπ leer, gib ùëÜ zur√ºck
2. Entferne das erste Elemente ùëí aus ùêπ
3. F√ºge ùëí in ùëÜ an die korrekte Stelle ein
4. Beginne wieder mit 1.


Beispiel: ùêπ = (21, 5, 3, 17)
ùëÜ = () ùêπ = (21, 5, 3, 17)
ùëÜ = (21) ùêπ = (5, 3, 17)
ùëÜ = (5, 21) ùêπ = (3, 17)
ùëÜ = (3, 5, 21) ùêπ = (17)
ùëÜ = (3, 5, 17, 21) ùêπ = ()


Die Laufzeit von Insertion Sort im schlechtesten Fall ist O(n^2), da f√ºr jedes der n Elemente in F im schlimmsten Fall bis zu n Vergleiche in S durchgef√ºhrt werden m√ºssen, um die korrekte Einf√ºgestelle zu finden.
Altklausurenaufgabe: 2024_1 / Aufgabe 7
https://moodle.uni-ulm.de/pluginfile.php/1348606/mod_folder/content/0/2024_1_exam.pdf

L√∂sung:
https://moodle.uni-ulm.de/pluginfile.php/1348606/mod_folder/content/0/2024_1_solution.pdf








bislang haben wir f√ºr alle Sortieralgorithmen eine Laufzeit von O(n^2). das geht aber schneller!

Merge Sort
Gegeben eine zu sortierende Liste ùêπ.
1. Enth√§lt ùêπ ein oder null Elemente, gib ùêπ zur√ºck
2. Teile ùêπ in ùêπ1 und ùêπ2 mit m√∂glichst gleicher L√§nge auf
3. F√ºhre MergeSort auf ùêπ1 und ùêπ2 aus
4. F√ºge ùêπ1 und ùêπ2 geordnet in ùêπ zusammen, da beide sortiert sind m√ºssen immer
nur die ersten beiden Elemente verglichen werden und das jeweils kleinere zuerst
angef√ºgt werden
5. Gib ùêπ zur√ºck

ùêπ = (21, 5, 3, 17)


           (21, 5, 3, 17)       |
           /           \   
        (21, 5)     (3, 17)     | aufspalten
        /    \       /    \
       (21)  (5)   (3)  (17)    |
         \   /       \     /
         (5, 21)     (3, 17)    | zusammenf√ºhren/ merge (hier ist die eigentliche Arbeit)
            \           /
            (3, 5, 17, 21)      |

Die Laufzeit von Merge Sort im schlechtesten Fall ist O(n log n), da die Liste in jedem Schritt halbiert wird (log n Schritte) und in jedem Schritt alle n Elemente verglichen und zusammengef√ºhrt werden m√ºssen.

Altklausurenaufgabe: 2023_2 / Aufgabe 6
https://moodle.uni-ulm.de/pluginfile.php/1348606/mod_folder/content/0/2023_2_exam.pdf


L√∂sung: 
https://moodle.uni-ulm.de/pluginfile.php/1348606/mod_folder/content/0/2023_2_solution.pdf





Quick Sort
Gegeben eine zu sortierende Liste ùêπ.
1. Enth√§lt ùêπ ein oder null Elemente, gib ùêπ zur√ºck
2. W√§hle ein Pivotelement
3. Teile ùêπ in ùêπ1 und ùêπ2 auf wobei in ùêπ1 nur Elemente kleiner als das Pivot Element
enthalten sind und in ùêπ2 nur Elemente gr√∂√üer gleich
4. F√ºhre Quicksort auf ùêπ1 und ùêπ2 aus
5. F√ºge alle Elemente aus ùêπ1 an ùêπ an
6. F√ºge das Pivotelement an ùêπ an
7. F√ºge alle Elemente aus ùêπ2 an ùêπ an
8. Gib ùêπ zur√ºck


=> Altkausurenaufgabe 2023_1 / Aufgabe 6
https://moodle.uni-ulm.de/pluginfile.php/1348606/mod_folder/content/0/2023_1_exam.pdf

L√∂sung: 
https://moodle.uni-ulm.de/pluginfile.php/1348606/mod_folder/content/0/2023_1_solution.pdf


Die Laufzeit von Quick Sort im schlechtesten Fall ist O(n^2), wenn das Pivotelement immer das gr√∂√üte oder kleinste Element ist, wodurch die Liste nicht effektiv geteilt wird.
Im Durchschnitt betr√§gt die Laufzeit jedoch O(n log n), da die Liste in der Regel gut geteilt wird und die gleichen √úberlegungen wie bei Merge Sort gelten.